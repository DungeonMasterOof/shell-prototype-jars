## Task 5   

#### БНФ

`<команда shell> ::= <список команд>`  
`<список команд> ::= <конвейер> {[один из &, ;, &&, ||]<конвейер>} [&, ;]`  
`<конвейер> ::= <команда> {|<команда>}`  
`<команда> ::= <имя файла> {<аргумент>} [ < <имя файла>] [[один из >, >>] <имя файла>]`  

---

#### Структура shell

Шелл jars работает по принципу рекурсивного спуска. **jars - Just Another Ruslan Shell**  
В шелле реализованы *&, ;, |, <, >, >>, $HOME, $USER, $EUID, $SHELL, cd, pwd, exit*  
Весь шелл состоит из 5 модулей: *list.c, list.h, exec.c, exec.h, jars.c*  
list.h и exec.h - заголовочные файлы, содержащие описания функций list.c  
и exec.c соответственно. jars.c - главный модуль всей программы.   
Разберём 3 основных файла:   

---

###### list.c

В этом модуле описаны функции работы со списками list, у которых элементами являются строки (слова или же лексемы). Работает идентично Task 3: 
разбиваем строку слов на список слов. Специальными символами являются |, &, ;, <, >.   
Всё, что находится в " ", считается одним словом и к содержимому не применяются никакие ограничения (проверки не выполняются). Сигнатуры функций:  

`void dellist(list* lst)`  
Очищение всего списка из динамической памяти  


`void addtolist(list* lst, char str[])`  
Добавляем слово str в конец списка lst  


`void printlist(list lst)`  
Функция вывода содержимого всего списка. В основном используется для отладки  


`void addtoword(char* word, int* index, char c)`  
Функция добавляет символ c к слову word по индексу index.  
Она также увеличивает этот индекс на 1.  
В основном эта функция используется для посимвольного формирования слов.  


`int isvalidchr(char c)`  
Проверка символа на соответствие шеллу. Например, ( и ) не поддерживаются,  
и шелл выдаст ошибку.  


`int formlist(list *dst, char str[])`  
Самая важная функция в list.c  
Она занимается формировкой списка по строке str и возвращает результат в dst  
Посимвольно считываем str и запоминаем с помощью флагов то, находимся ли мы  
в escape-последовательности (т.е. была до текущего символа \ ) или находимся в " "  
Учитывая эти параметры, она формирует слово до встречи с пробелом (если мы не в " ")
или до конца " ".   
Также мы считываем отдельным образом специальные символы (см начало раздела) и  
записываем их по одному (<, &, ;, |) или, возможно, по двое (> или >>)  

---

###### exec.c

Это модуль, в котором выполняется вся работа по уровням команды shell, конвейера,  
команды. Вот нам подали "сырой" список слов от *formlist()*, и нужно его обработать.  

`int jars(list s, char* n)`   
Функция для обработки на уровне команды shell. Мы обрабатываем "сырой" список слов s,  
и разбиваем его, согласно БНФ, на конвейеры (т.е. списки, разделённые между собой |) и обрабатываем некоторые специальные команды (&, ;).  
Для обработки & мы вызываем подшеллы (subshells), и в самом главном шелле отлавливаем сигналы и ошибки подшеллов.  
Для каждого конвейера (который в глобальной переменной conveyor) вызываем функцию *proc_conveyor()*, т.е. спускаемся на 1 уровень.  


`void proc_conveyor()`  
В этой функции список-конвейер разбивается на ещё более мелкие составляющие: команды и |.   
Мы открываем канал и обрабатываем команду до встречи |. Далее создаём сыновий процесс и в нём спускаемся   
на уровень ниже, если | нет, иначе перенаправляем стандартные ввод и вывод в канал и тогда спускаемся  
на уровень ниже. Наконец, уровень команды - *proc_command()*  


`void proc_command()`  
Именно здесь мы отлавливаем ошибки с помощью errno и проверяем на ошибки список-команду.  
Сама команда по нашей структуре находится в самом начале списка, а затем идут только аргументы к ней.  
На этом уровне мы обрабатываем < > >>, у которых наивысший приоритет. Если неверно использованы < или > (>>), за чем следят особые флаги,   
то выходим с ошибкой. Также обеспечиваем и их использование (открываем файлы с нужными флагами и перенаправляем стандартные потоки ввода или вывода).   
Если всё нормально и ошибок нет, то формируем буфер аргументов команды подобно argv: в 0 индексе находится сама команда, а дальше - аргументы.  
После этого мы проверяем, не является ли поступившая команда внутренней командой шелл: cd или exit. Если **это первая команд** и она внутренняя,  
то обрабатываем их по-особому: на exit мы прекращаем выполнение всей команды шелла, а на cd мы также завершаем команду шелла меняем каталог.  
Иначе игнорируем их. Если же поступившая команда не является внутренней для шелла, то создаём сыновий процесс и в нём вызываем *execvp()*   
с нашими аргументами. Также отлавливаем разные сигналы и, в частности, SIGPIPE.   


`void shell_var(char *args[], int ofs)`  
Эта функция заполняет глобальные переменные, отвечающие за $HOME, $SHELL, $USER, $EUID.  
Она используется в *proc_command()* для обновления данных окружения для соответствия их текущей выполняемой команды.  

---

###### jars.c  

Главный модуль всей программы. Именно здесь формируется текстовый интерфейс шелла и строка с введёнными данными,  
которая далее уже подаётся на *jars()* из exec.c. Ну и также обработчик SIGINT, при получении которого мы просто завершаем шелл с кодом 0.  
Если у нас есть запущенные в фоновом режиме команды, то они продолжают выполняться независимо от того, главный шелл завершился или нет.  

---

## Тесты  

###### Верные команды  


`CTRL + D`  

Завершение работы шелла  

`cd`
`pwd`

Перешли в домашнюю директорию  


`who | cat > file.out`

Информация о пользователе пишется в file.out  


`yes | head`  

Печатает 10 раз букву y  


`echo "We can do better!" & sleep 5`  

Скажет We can do better! и уснёт на 5 секунд  


`sleep 5 & sleep 5 & sleep 5 & sleep 5 & sleep 5 &`  

Запустит 5 спящих подшеллов, которые вскоре завершатся (не останется зомби)  


`pwd | cd | exit | date | cat`  

Напечатает только текущую дату  


`echo MAMA MIA`  

Выведет всё как нужно  


`pwd && sleep 5 &`

pwd выполнится => запустится sleep 5 в фоновом режиме. Это можно отследить через &

---

###### Неверные команды  

`echo "MAMA MIA`  

Ошибка во время создания списка: нет закрывающей кавычки  


`(ls & sleep 5) | cat`   

Ошибка: встречен неподдерживаемый символ (  
Скобки не были реализованы, так что шелл их не поддерживает  


`
